{
  "name": "pauseable",
  "description": "Create event emitters, intervals, and timeouts that can be paused and resumed.",
  "keywords": [
    "event",
    "emitter",
    "timer",
    "interval",
    "timeout",
    "pause",
    "resume"
  ],
  "version": "0.1.2",
  "homepage": "https://github.com/fent/pauseable.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/fent/pauseable.js.git"
  },
  "author": {
    "name": "Roly Fentanes",
    "url": "https://github.com/fent"
  },
  "main": "./lib/index.js",
  "scripts": {
    "test": "mocha -R spec test/*-test.js"
  },
  "directories": {
    "lib": "./lib"
  },
  "devDependencies": {
    "mocha": "x"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/fent/pauseable.js/raw/master/LICENSE"
    }
  ],
  "readme": "# Pauseable [![Build Status](https://secure.travis-ci.org/fent/node-feedsub.png)](http://travis-ci.org/fent/node-feedsub)\n\nPauseable allows you to pause event emitters, timeouts, and intervals. It can easily group multiple of these pauseable objects and pause entire groups.\n\n# Usage\n\n## Using pauseable with EventEmitter\n\n```javascript\nvar pauseable = require('pauseable')\n  , EventEmitter = require('events').EventEmitter\n  ;\n\nvar ee = new EventEmitter();\n\nee.on('foo', function() { ... });\n\n// ...later\npauseable.pause(ee);\n\n// this event will not be immediately fired\n// instead, it will be buffered\nee.emit('foo', 'hellow');\n\n// ...much later\n// the 'foo' event will be fired at this point\npauseable.resume(ee);\n```\n\n## Comes with pauseable setTimeout and setInterval too\n\n```javascript\nvar timeout = pauseable.setTimeout(function() {\n  // this will take 8 seconds total to execute\n  // not 5\n}, 5000);\n\n// pause timeout after 2 secs\nsetTimeout(function() {\n  timeout.pause();\n  timeout.isPaused(); // true\n  \n  // resume after 3\n  setTimeout(function() {\n    timeout.resume();\n  }, 3000);\n}, 2000);\n```\n\nThe `function` and `ms` arguments are interchangeable. Use whichever way you prefer!\n\n```javascript\nvar interval = pauseable.setInterval(5000, function() {\n  // this is called after 5 seconds\n  // then paused for 2 seconds\n  interval.pause(2000);\n});\n```\n\n## Grouping\n\n```javascript\n// create a group\nvar g = pauseable.createGroup();\n\n// make and add emitters to group\nvar ee1 = g.add(new EventEmitter());\nvar ee2 = g.add(new EventEmitter());\n\nee1.on('forth', function() {\n  // pause entire group (that means ee1 and ee2) for 500 ms\n  // timeout is out of the group by the time this executes\n  g.pause(500);\n  console.log('forth');\n  ee2.emit('back');\n});\n\nee2.on('back', function() {\n  console.log('back');\n  ee1.emit('forth');\n});\n\nvar timeout = g.setTimeout(function() {\n  ee2.emit('back', 'poop');\n}, 1000);\n```\n\n# Motive\n\nJavascript is event based by nature. When developing large scale applications that are completely event based, it becomes complicated to pause the streaming of events, because Javascript never \"sleeps\". It becomes even more complicated to pause timeouts and intervals having to keep track of when they were paused so they can be resumed with the correct time again.\n\nThat's where this module comes in. Pauseable helps manage pausing and resuming your application or part of it. It works with EventEmitter and with setInterval and setTimeout.\n\n\n# API\n\n## Events\n### pauseable.pause(ee, [ms])\nPauses an instance of EventEmitter. All events get buffered and emitted once the emitter is resumed. Currently only works with EventEmitters. Optional `ms` will pause only for that long.\n\n### pauseable.resume(ee, [ms])\nResumes the emitter. Events can be emitted again. Optional `ms` will resume only for that long.\n\n\n## Timers\n### pauseable.setTimeout(fn, ms) and pauseable.setInterval(fn, ms)\nCreates a pauseable timeout or interval. `fn` and `ms` are interchangeabale. Returns an instance of timer.\n\n### timer.pause([ms])\nPauses timer. Optional `ms` will pause the timer only for that amount.\n\n### timer.resume([ms])\nResumes timer. Optional `ms` will resume the timer only for that amount.\n\n### timer.next()\nReturns the number of ms left until the `fn` function in the constructor gets called again.\n\n### timer.clear()\nClears timeout. Can no longer be resumed.\n\n### timer.isPaused()\nReturns `true` if timer is currently paused.\n\n### timer.isDone()\nReturns `true` if timer was a timeout and `fn` was called, or `timer.clear()` has been called.\n\n### timer.onDone(callback)\nIf timer is a timeout, this can be used to execute the `callback` when the `fn` in the constructor is called.\n\n\n## Groups\n### pauseable.createGroup()\nCreates a `group` where emitters and timers can be easily managed.\n\n### group.add()\nAdd an emitter or a timer to the group. Returns added emitter/timer.\n\n### group.setTimeout(fn, ms)\n### group.setInterval(fn, ms)\nShortcut to create an instance of a timer and add it to the group.\n\n### group.pause([ms])\nPauses all emitters and timers in the group.\n\n### group.resume([ms])\nResumes all emitters and timers in the group.\n\n### group.clear()\nClears timers in the group.\n\n### group.isPaused()\nReturns `true` is group is paused.\n\n### group.isDone()\nReturns `true` if all timers currently in the group are timeouts and their original function has been called or all timers have been cleared.\n\n### group.timers()\nContains both emitters and timers. Useful if you want to micro manage more.\n\n\n# Install\n\n    npm install pauseable\n\n\n# Tests\nTests are written with [mocha](http://visionmedia.github.com/mocha/)\n\n```bash\nnpm test\n```\n\n\n# License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/fent/pauseable.js/issues"
  },
  "_id": "pauseable@0.1.2",
  "dist": {
    "shasum": "969b1d2d1e1a0b6a13187c2a147aa18fad5fc4ef"
  },
  "_from": "pauseable@",
  "_resolved": "https://registry.npmjs.org/pauseable/-/pauseable-0.1.2.tgz"
}
